# Web-Develop-Log

-----

## 인증 방식 종류 (Cookie & Session & Token)<br>
 
 보통 서버가 클라이언트 인증을 확인하는 방식은 대표적으로 쿠키, 세션, 토큰 3가지 방식이 있다.<br>
 JWT는 배우기 앞서서 우선 쿠키와 세션의 통신 방식을 배우고 이들의 각각 특징과 장단점 그리고 왜 토큰 인증 방식을 사용하는지에 대해 알아보자. <br>
 

-----
## Cookie 인증<br>

 쿠키는 Key-Value 형식의 문자열 덩어리이다.<br>
 클라이언트가 어떠한 웹사이트를 방문할 경우,<br>
 그 사이트가 사용하고 있는 서버를 통해 클라이언트의 브라우저에 설치되는 작은 기록 정보 파일이다.<br>
 각 사용자마다의 브라우저에 정보를 저장하니 고유 정보 식별이 가능한 것이다.<br>

  > * 1. 브라우저(클라이언트)가 서버에 요청(접속)을 보낸다.<br>
  > * 2. 서버는 클라이언트의 요청에 대한 응답을 작성할 때, 클라이언트 측에 저장하고 싶은 정보를 응답 헤더의 Set-Cookie에 담는다.<br>
  > * 3. 이후 해당 클라이언트는 요청을 보낼 때마다, 매번 저장된 쿠키를 요청 헤더의 Cookie에 담아 보낸다.<br>
  > * 4. 서버는 쿠키에 담긴 정보를 바탕으로 해당 요청의 클라이언트가 누군지 식별하거나 정보를 바탕으로 추천 광고를 띄우거나 한다.<br>
   
### Cookie 방식의 단점<br>

> * 1. 가장 큰 단점은 보안에 취약하다는 점이다.<br>
> * 2. 요청 시 쿠키의 값을 그대로 보내기 때문에 유출 및 조작 당할 위험이 존재한다.<br>
> * 3. 쿠키에는 용량 제한이 있어 많은 정보를 담을 수 없다.<br>
> * 4. 웹 브라우저마다 쿠키에 대한 지원 형태가 다르기 때문에 브라우저간 공유가 불가능하다.<br>
> * 5. 쿠키의 사이즈가 커질수록 네트워크에 부하가 심해진다.<br>

-----

## Session 인증<br>

세션은 비밀번호 등 클라이언트의 민감한 인증 정보를 브라우저가 아닌 서버 측에 저장하고 관리한다.<br>
서버의 메모리에 저장하기도 하고, 서버의 로컬 파일이나 데이터베이스에 저장하기도 한다.<br> 
핵심 골자는 민감한 정보는 클라이언트에 보내지말고 서버에서 모두 관리한다는 점이다.<br>

 > * 세션 객체는 어떤 형태로 이루어져 있을까? * <br>
 > * 세션 객체는 Key에 해당하는 SESSION ID와 이에 대응하는 Value로 구성되어 있다.<br>
 > * Value에는 세션 생성 시간, 마지막 접근 시간 및 User가 저장한 속성 등 이 Map 형태로 저장된다.<br>
 

### Session 인증 방식<br>

> * 1. 유저가 웹사이트에서 로그인하면 세션이 서버 메모리(혹은 데이터베이스) 상에 저장된다.<br>
> *    이때, 세션을 식별하기 위한 Session Id를 기준으로 정보를 저장한다. <br>
> * 2. 서버에서 브라우저에 쿠키에다가 Session Id를 저장한다.<br>
> * 3. 쿠키에 정보가 담겨있기 때문에 브라우저는 해당 사이트에 대한 모든 Request에 Session Id를 쿠키에 담아 전송한다.<br>
> * 3. 서버는 클라이언트가 보낸 Session Id 와 서버 메모리로 관리하고 있는 Session Id를 비교하여 인증을 수행한다.<br>

### Session 방식의 단점

> * 1. 쿠키를 포함한 요청이 외부에 노출되더라도 세션 ID 자체는 유의미한 개인정보를 담고 있지 않는다.<br>
> 그러나 해커가 세션 ID 자체를 탈취하여 클라이언트인척 위장할 수 있다는 한계가 존재한다. (이는 서버에서 IP특정을 통해 해결 할 수 있긴 하다)
> * 2. 서버에서 세션 저장소를 사용하므로 요청이 많아지면 서버에 부하가 심해진다.
 
-----

### Token 인증<br>

토큰 기반 인증 시스템은 클라이언트가 서버에 접속을 하면 서버에서 해당 클라이언트에게 인증되었다는 의미로 '토큰'을 부여한다.<br>
이 토큰은 유일하며 토큰을 발급받은 클라이언트는 또 다시 서버에 요청을 보낼 때 요청 헤더에 토큰을 심어서 보낸다.<br>
그러면 서버에서는 클라이언트로부터 받은 토큰을 서버에서 제공한 토큰과의 일치 여부를 체크하여 인증 과정을 처리하게 된다.<br><br>
 
기존의 세션기반 인증은 서버가 파일이나 데이터베이스에 세션정보를 가지고 있어야 하고 이를 조회하는 과정이 필요하기 때문에 많은 오버헤드가 발생한다.<br>
하지만 토큰은 세션과는 달리 서버가 아닌 클라이언트에 저장되기 때문에 메모리나 스토리지 등을 통해 세션을 관리했던 서버의 부담을 덜 수 있다.<br>
토큰 자체에 데이터가 들어있기 때문에 클라이언트에서 받아 위조되었는지 판별만 하면 되기 떄문이다.<br><br>
 
토큰은 앱과 서버가 통신 및 인증할때 가장 많이 사용된다.<br>
왜냐하면 웹에는 쿠키와 세션이 있지만 앱에서는 없기 때문이다.<br>

-----

## 서버 기반 vs 토큰 기반<br>

서버(세션) 기반 인증 시스템서버의 세션을 사용해 사용자 인증을 하는 방법으로<br>
서버측(서버 램 or 데이터베이스)에서 사용자의 인증정보를 관리하는 것을 의미한다.<br>
그러다 보니, 클라이언트로부터 요청을 받으면 클라이언트의 상태를 계속에서 유지해놓고 사용한다.<br>
(Stateful) 이는 사용자가 증가함에 따라 성능의 문제를 일으킬 수 있으며 확장성이 어렵다는 단점을 지닌다.<br>
토큰 기반 인증 시스템이러한 단점을 극복하기 위해서 "토큰 기반 인증 시스템"이 나타났다.인증받은 사용자에게 토큰을 발급하고,<br>
로그인이 필요한 작업일 경우 헤더에 토큰을 함께 보내 인증받은 사용자인지 확인한다.<br>
이는 서버 기반 인증 시스템과 달리 상태를 유지하지 않으므로 Stateless 한 특징을 가지고 있다.<br>
	

### Token 인증 방식<br>

> * 1. 사용자가 아이디와 비밀번호로 로그인을 한다.<br>
> * 2. 서버 측에서 사용자(클라이언트)에게 유일한 토큰을 발급한다.<br>
> * 3. 클라이언트는 서버 측에서 전달받은 토큰을 쿠키나 스토리지에 저장해 두고,<br>
> *    서버에 요청을 할 때마다 해당 토큰을 HTTP 요청 헤더에 포함시켜 전달한다.<br>
> * 4. 서버는 전달받은 토큰을 검증하고 요청에 응답한다.<br>
> *    토큰에는 요청한 사람의 정보가 담겨있기에 서버는 DB를 조회하지 않고 누가 요청하는지 알 수 있다.

### Token 방식의 단점

> * 쿠키/세션과 다르게 토큰 자체의 데이터 길이가 길어, 인증 요청이 많아질수록 네트워크 부하가 심해질수 있다.<br>
> * Payload 자체는 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 없다.<br>
> * 토큰을 탈취당하면 대처하기 어렵다. (따라서 사용 기간 제한을 설정하는 식으로 극복한다)<br>

-----

# JWT (JSON Web Token)

JWT(JSON Web Token)란 인증에 필요한 정보들을 암호화시킨 JSON 토큰을 의미한다.<br>
그리고 JWT 기반 인증은 JWT 토큰(Access Token)을 HTTP 헤더에 실어 서버가 클라이언트를 식별하는 방식이다<br>
 
JWT는 JSON 데이터를 Base64 URL-safe Encode 를 통해 인코딩하여 직렬화한 것이며,<br> 
토큰 내부에는 위변조 방지를 위해 개인키를 통한 전자서명도 들어있다.<br>
따라서 사용자가 JWT 를 서버로 전송하면 서버는 서명을 검증하는 과정을 거치게 되며 검증이 완료되면 요청한 응답을 돌려준다.

> Base64 URL-safe Encode 는 일반적인 Base64 Encode 에서 URL 에서 오류없이 사용하도록<br>
>  '+', '/' 를 각각 '-', '_' 로 표현한 것이다.<br>

## JWT 구조

JWT는 . 을 구분자로 나누어지는 세 가지 문자열의 조합이다.<br>
. 을 기준으로 좌측부터 Header(헤더), Payload(내용), Signature(서명)를 의미한다.<br><br>

XXXXXX .  YYYYYY  . ZZZZZZ <br>
(Header) (Payload)  (Signature) <br><br>

> * Header 에는 JWT 에서 사용할 타입과 해시 알고리즘의 종류가 담겨있으며,<br>
> * Payload 는 서버에서 첨부한 사용자 권한 정보와 데이터가 담겨있다.<br>
> * 마지막으로 Signature 에는 Header, Payload 를 Base64 URL-safe Encode 를 한 이후<br>
> * Header 에 명시된 해시함수를 적용하고, 개인키(Private Key)로 서명한 전자서명이 담겨있다.<br>
> * 전자서명에는 비대칭 암호화 알고리즘을 사용하므로 암호화를 위한 키와 복호화를 위한 키가 다르다.<br>
> * 암호화(전자서명)에는 개인키를, 복호화(검증)에는 공개키를 사용한다.<br><br>
 
 
__실제 디코딩된 JWT는 다음과 같은 구조를 지닌다.__


> __Header_ <br>
> { <br>
> 	"alg" : "HS256",<br>
> 	"typ" : "JWT"<br>
> }<br>
> alg : 서명 암호화 알고리즘<br>
> typ : 토큰 유형<br><br>

> __Payload__<br>
> 토큰에서 사용할 정보의 조각들인 Claim 이 담겨있다. (실제 JWT 를 통해서 알 수 있는 데이터)<br>
> 즉, 서버와 클라이언트가 주고받는 시스템에서 실제로 사용될 정보에 대한 내용을 담고 있는 섹션이다.<br>
> __key-value 형식으로 이루어진 한 쌍의 정보를 Claim이라고 칭한다.__<br>
> {<br>
> "sub" : "1234567890"<br>
> "name" : "Rio Park"<br>
> "iat" : 151923847<br>
> }<br><br>

> __Signature__ <br>
> 시그니처에서 사용하는 알고리즘은 헤더에서 정의한 알고리즘 방식(alg)을 활용한다.<br>
> 시그니처의 구조는 (헤더 + 페이로드)와 서버가 갖고 있는 유일한 key 값을 합친 것을 <br>
> 헤더에서 정의한 알고리즘으로 암호화를 한다.<br>
> __Signature = (Base64URL(Header) +.+ Base64URL(Payload) +.+ Server's key) <-- HS256__ <br>
> * tip 
> Header와 Payload는 단순히 인코딩된 값이기 때문에 제 3자가 복호화 및 조작할 수 있지만,<br> 
> Signature는 서버 측에서 관리하는 비밀키가 유출되지 않는 이상 복호화할 수 없다.<br>
> 따라서 Signature는 토큰의 위변조 여부를 확인하는데 사용된다.<br><br>
	
## JWT를 이용한 인증 과정<br>
	
> * 1. 사용자가 ID, PW를 입력하여 서버에 로그인 인증을 요청한다.<br>
> * 2. 서버에서 클라이언트로부터 인증 요청을 받으면, Header, PayLoad, Signature를 정의한다.<br>
> * 3. Hedaer, PayLoad, Signature를 각각 Base64로 한 번 더 암호화하여 JWT를 생성하고 이를 쿠키에 담아 클라이언트에게 발급한다.<br>
> * 4.클라이언트는 서버로부터 받은 JWT를 로컬 스토리지에 저장한다. (쿠키나 다른 곳에 저장할 수도 있음) <br>
> * 5. API를 서버에 요청할때 Authorization header에 Access Token을 담아서 보낸다. <br>
> * 6. 서버가 할 일은 클라이언트가 Header에 담아서 보낸 JWT가 내 서버에서 발행한 토큰인지 일치 여부를 확인하여 <br>
> * 일치한다면 인증을 통과시켜주고 아니라면 통과시키지 않으면 된다.<br>
> * 7. 인증이 통과되었으므로 페이로드에 들어있는 유저의 정보들을 select해서 클라이언트에 돌려준다.<br>
> * 8. 클라이언트가 서버에 요청을 했는데, 만일 액세스 토큰의 시간이 만료되면 클라이언트는 리프래시 토큰을 이용해서<br>
> * 서버로부터 새로운 엑세스 토큰을 발급 받는다.<br><br>

## JWT 장점<br>

> * 1. Header와 Payload를 가지고 Signature를 생성하므로 데이터 위변조를 막을 수 있다.<br>
> * 2. 인증 정보에 대한 별도의 저장소가 필요없다.<br>
> * 3. JWT는 토큰에 대한 기본 정보와 전달할 정보 및 토큰이 검증됬음을 증명하는 서명 등 필요한 모든 정보를 자체적으로 지니고 있다.<br>
> * 4. 클라이언트 인증 정보를 저장하는 세션과 다르게, 서버는 무상태(StateLess)가 된다.<br>
> * 5. 확장성이 우수하다.<br>
> * 6. 토큰 기반으로 다른 로그인 시스템에 접근 및 권한 공유가 가능하다. (쿠키와 차이)<br>
> * 7. OAuth의 경우 Facebook, Google 등 소셜 계정을 이용하여 다른 웹서비스에서도 로그인을 할 수 있다.<br>
> * 8. 모바일 어플리케이션 환경에서도 잘 동작한다. (모바일은 세션 사용 불가능)<br><br>

## JWT 단점<br>

> * 1. 쿠키/세션과 다르게 JWT는 토큰의 길이가 길어, 인증 요청이 많아질수록 네트워크 부하가 심해진다.<br>
> * 2. Payload 자체는 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 없다.<br>
> * 3. 토큰을 탈취당하면 대처하기 어렵다.<br>


[인파님 Dev Scorll](https://inpa.tistory.com/entry/WEB-📚-JWTjson-web-token-란-💯-정리)
